// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -package repo -source=interfaces.go -destination=interfaces_mock.go Repo
//

// Package repo is a generated GoMock package.
package repo

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	orm "github.com/crlssn/getstronger/server/gen/orm"
	gomock "go.uber.org/mock/gomock"
)

// MockRepo is a mock of Repo interface.
type MockRepo struct {
	ctrl     *gomock.Controller
	recorder *MockRepoMockRecorder
	isgomock struct{}
}

// MockRepoMockRecorder is the mock recorder for MockRepo.
type MockRepoMockRecorder struct {
	mock *MockRepo
}

// NewMockRepo creates a new mock instance.
func NewMockRepo(ctrl *gomock.Controller) *MockRepo {
	mock := &MockRepo{ctrl: ctrl}
	mock.recorder = &MockRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepo) EXPECT() *MockRepoMockRecorder {
	return m.recorder
}

// AddExerciseToRoutine mocks base method.
func (m *MockRepo) AddExerciseToRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddExerciseToRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddExerciseToRoutine indicates an expected call of AddExerciseToRoutine.
func (mr *MockRepoMockRecorder) AddExerciseToRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddExerciseToRoutine", reflect.TypeOf((*MockRepo)(nil).AddExerciseToRoutine), ctx, exercise, routine)
}

// CompareEmailAndPassword mocks base method.
func (m *MockRepo) CompareEmailAndPassword(ctx context.Context, email, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompareEmailAndPassword", ctx, email, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompareEmailAndPassword indicates an expected call of CompareEmailAndPassword.
func (mr *MockRepoMockRecorder) CompareEmailAndPassword(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompareEmailAndPassword", reflect.TypeOf((*MockRepo)(nil).CompareEmailAndPassword), ctx, email, password)
}

// CountNotifications mocks base method.
func (m *MockRepo) CountNotifications(ctx context.Context, opts ...CountNotificationsOpt) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountNotifications", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountNotifications indicates an expected call of CountNotifications.
func (mr *MockRepoMockRecorder) CountNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountNotifications", reflect.TypeOf((*MockRepo)(nil).CountNotifications), varargs...)
}

// CreateAuth mocks base method.
func (m *MockRepo) CreateAuth(ctx context.Context, email, password string) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAuth", ctx, email, password)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAuth indicates an expected call of CreateAuth.
func (mr *MockRepoMockRecorder) CreateAuth(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAuth", reflect.TypeOf((*MockRepo)(nil).CreateAuth), ctx, email, password)
}

// CreateExercise mocks base method.
func (m *MockRepo) CreateExercise(ctx context.Context, p CreateExerciseParams) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateExercise", ctx, p)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateExercise indicates an expected call of CreateExercise.
func (mr *MockRepoMockRecorder) CreateExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExercise", reflect.TypeOf((*MockRepo)(nil).CreateExercise), ctx, p)
}

// CreateNotification mocks base method.
func (m *MockRepo) CreateNotification(ctx context.Context, p CreateNotificationParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNotification", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MockRepoMockRecorder) CreateNotification(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*MockRepo)(nil).CreateNotification), ctx, p)
}

// CreateRoutine mocks base method.
func (m *MockRepo) CreateRoutine(ctx context.Context, p CreateRoutineParams) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRoutine", ctx, p)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRoutine indicates an expected call of CreateRoutine.
func (mr *MockRepoMockRecorder) CreateRoutine(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRoutine", reflect.TypeOf((*MockRepo)(nil).CreateRoutine), ctx, p)
}

// CreateUser mocks base method.
func (m *MockRepo) CreateUser(ctx context.Context, p CreateUserParams) (*orm.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, p)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockRepoMockRecorder) CreateUser(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockRepo)(nil).CreateUser), ctx, p)
}

// CreateWorkout mocks base method.
func (m *MockRepo) CreateWorkout(ctx context.Context, p CreateWorkoutParams) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorkout", ctx, p)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkout indicates an expected call of CreateWorkout.
func (mr *MockRepoMockRecorder) CreateWorkout(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkout", reflect.TypeOf((*MockRepo)(nil).CreateWorkout), ctx, p)
}

// CreateWorkoutComment mocks base method.
func (m *MockRepo) CreateWorkoutComment(ctx context.Context, p CreateWorkoutCommentParams, opts ...CreateWorkoutCommentOpts) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, p}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkoutComment indicates an expected call of CreateWorkoutComment.
func (mr *MockRepoMockRecorder) CreateWorkoutComment(ctx, p any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, p}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkoutComment", reflect.TypeOf((*MockRepo)(nil).CreateWorkoutComment), varargs...)
}

// DeleteRoutine mocks base method.
func (m *MockRepo) DeleteRoutine(ctx context.Context, routineID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRoutine", ctx, routineID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRoutine indicates an expected call of DeleteRoutine.
func (mr *MockRepoMockRecorder) DeleteRoutine(ctx, routineID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRoutine", reflect.TypeOf((*MockRepo)(nil).DeleteRoutine), ctx, routineID)
}

// DeleteWorkout mocks base method.
func (m *MockRepo) DeleteWorkout(ctx context.Context, opts ...DeleteWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteWorkout indicates an expected call of DeleteWorkout.
func (mr *MockRepoMockRecorder) DeleteWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkout", reflect.TypeOf((*MockRepo)(nil).DeleteWorkout), varargs...)
}

// Follow mocks base method.
func (m *MockRepo) Follow(ctx context.Context, p FollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Follow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Follow indicates an expected call of Follow.
func (mr *MockRepoMockRecorder) Follow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Follow", reflect.TypeOf((*MockRepo)(nil).Follow), ctx, p)
}

// GetAuth mocks base method.
func (m *MockRepo) GetAuth(ctx context.Context, opts ...GetAuthOpt) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAuth", varargs...)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuth indicates an expected call of GetAuth.
func (mr *MockRepoMockRecorder) GetAuth(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuth", reflect.TypeOf((*MockRepo)(nil).GetAuth), varargs...)
}

// GetExercise mocks base method.
func (m *MockRepo) GetExercise(ctx context.Context, opts ...GetExerciseOpt) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExercise", varargs...)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExercise indicates an expected call of GetExercise.
func (mr *MockRepoMockRecorder) GetExercise(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExercise", reflect.TypeOf((*MockRepo)(nil).GetExercise), varargs...)
}

// GetPersonalBests mocks base method.
func (m *MockRepo) GetPersonalBests(ctx context.Context, userIDs ...string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range userIDs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPersonalBests", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPersonalBests indicates an expected call of GetPersonalBests.
func (mr *MockRepoMockRecorder) GetPersonalBests(ctx any, userIDs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, userIDs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPersonalBests", reflect.TypeOf((*MockRepo)(nil).GetPersonalBests), varargs...)
}

// GetPreviousWorkoutSets mocks base method.
func (m *MockRepo) GetPreviousWorkoutSets(ctx context.Context, exerciseIDs []string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPreviousWorkoutSets", ctx, exerciseIDs)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPreviousWorkoutSets indicates an expected call of GetPreviousWorkoutSets.
func (mr *MockRepoMockRecorder) GetPreviousWorkoutSets(ctx, exerciseIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPreviousWorkoutSets", reflect.TypeOf((*MockRepo)(nil).GetPreviousWorkoutSets), ctx, exerciseIDs)
}

// GetRoutine mocks base method.
func (m *MockRepo) GetRoutine(ctx context.Context, opts ...GetRoutineOpt) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRoutine", varargs...)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRoutine indicates an expected call of GetRoutine.
func (mr *MockRepoMockRecorder) GetRoutine(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRoutine", reflect.TypeOf((*MockRepo)(nil).GetRoutine), varargs...)
}

// GetUser mocks base method.
func (m *MockRepo) GetUser(ctx context.Context, opts ...GetUserOpt) (*orm.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *MockRepoMockRecorder) GetUser(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockRepo)(nil).GetUser), varargs...)
}

// GetWorkout mocks base method.
func (m *MockRepo) GetWorkout(ctx context.Context, opts ...GetWorkoutOpt) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkout", varargs...)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkout indicates an expected call of GetWorkout.
func (mr *MockRepoMockRecorder) GetWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkout", reflect.TypeOf((*MockRepo)(nil).GetWorkout), varargs...)
}

// GetWorkoutComment mocks base method.
func (m *MockRepo) GetWorkoutComment(ctx context.Context, opts ...GetWorkoutCommentOpt) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkoutComment indicates an expected call of GetWorkoutComment.
func (mr *MockRepoMockRecorder) GetWorkoutComment(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkoutComment", reflect.TypeOf((*MockRepo)(nil).GetWorkoutComment), varargs...)
}

// IsUserFollowedByUserID mocks base method.
func (m *MockRepo) IsUserFollowedByUserID(ctx context.Context, user *orm.User, userID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUserFollowedByUserID", ctx, user, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUserFollowedByUserID indicates an expected call of IsUserFollowedByUserID.
func (mr *MockRepoMockRecorder) IsUserFollowedByUserID(ctx, user, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserFollowedByUserID", reflect.TypeOf((*MockRepo)(nil).IsUserFollowedByUserID), ctx, user, userID)
}

// ListExercises mocks base method.
func (m *MockRepo) ListExercises(ctx context.Context, opts ...ListExercisesOpt) (orm.ExerciseSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListExercises", varargs...)
	ret0, _ := ret[0].(orm.ExerciseSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListExercises indicates an expected call of ListExercises.
func (mr *MockRepoMockRecorder) ListExercises(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListExercises", reflect.TypeOf((*MockRepo)(nil).ListExercises), varargs...)
}

// ListFollowees mocks base method.
func (m *MockRepo) ListFollowees(ctx context.Context, userID string, opts ...ListFolloweesOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowees", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowees indicates an expected call of ListFollowees.
func (mr *MockRepoMockRecorder) ListFollowees(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowees", reflect.TypeOf((*MockRepo)(nil).ListFollowees), varargs...)
}

// ListFollowers mocks base method.
func (m *MockRepo) ListFollowers(ctx context.Context, userID string, opts ...ListFollowersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowers indicates an expected call of ListFollowers.
func (mr *MockRepoMockRecorder) ListFollowers(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowers", reflect.TypeOf((*MockRepo)(nil).ListFollowers), varargs...)
}

// ListNotifications mocks base method.
func (m *MockRepo) ListNotifications(ctx context.Context, opts ...ListNotificationsOpt) (orm.NotificationSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNotifications", varargs...)
	ret0, _ := ret[0].(orm.NotificationSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNotifications indicates an expected call of ListNotifications.
func (mr *MockRepoMockRecorder) ListNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNotifications", reflect.TypeOf((*MockRepo)(nil).ListNotifications), varargs...)
}

// ListRoutines mocks base method.
func (m *MockRepo) ListRoutines(ctx context.Context, opts ...ListRoutineOpt) (orm.RoutineSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRoutines", varargs...)
	ret0, _ := ret[0].(orm.RoutineSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRoutines indicates an expected call of ListRoutines.
func (mr *MockRepoMockRecorder) ListRoutines(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRoutines", reflect.TypeOf((*MockRepo)(nil).ListRoutines), varargs...)
}

// ListSets mocks base method.
func (m *MockRepo) ListSets(ctx context.Context, opts ...ListSetsOpt) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSets", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSets indicates an expected call of ListSets.
func (mr *MockRepoMockRecorder) ListSets(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSets", reflect.TypeOf((*MockRepo)(nil).ListSets), varargs...)
}

// ListUsers mocks base method.
func (m *MockRepo) ListUsers(ctx context.Context, opts ...ListUsersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUsers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUsers indicates an expected call of ListUsers.
func (mr *MockRepoMockRecorder) ListUsers(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockRepo)(nil).ListUsers), varargs...)
}

// ListWorkouts mocks base method.
func (m *MockRepo) ListWorkouts(ctx context.Context, opts ...ListWorkoutsOpt) (orm.WorkoutSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkouts", varargs...)
	ret0, _ := ret[0].(orm.WorkoutSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkouts indicates an expected call of ListWorkouts.
func (mr *MockRepoMockRecorder) ListWorkouts(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkouts", reflect.TypeOf((*MockRepo)(nil).ListWorkouts), varargs...)
}

// MarkNotificationsAsRead mocks base method.
func (m *MockRepo) MarkNotificationsAsRead(ctx context.Context, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkNotificationsAsRead", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkNotificationsAsRead indicates an expected call of MarkNotificationsAsRead.
func (mr *MockRepoMockRecorder) MarkNotificationsAsRead(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkNotificationsAsRead", reflect.TypeOf((*MockRepo)(nil).MarkNotificationsAsRead), ctx, userID)
}

// NewTx mocks base method.
func (m *MockRepo) NewTx(ctx context.Context, f func(Tx) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewTx", ctx, f)
	ret0, _ := ret[0].(error)
	return ret0
}

// NewTx indicates an expected call of NewTx.
func (mr *MockRepoMockRecorder) NewTx(ctx, f any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewTx", reflect.TypeOf((*MockRepo)(nil).NewTx), ctx, f)
}

// PostCreateWorkoutCommentLoadUser mocks base method.
func (m *MockRepo) PostCreateWorkoutCommentLoadUser(ctx context.Context) CreateWorkoutCommentOpts {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostCreateWorkoutCommentLoadUser", ctx)
	ret0, _ := ret[0].(CreateWorkoutCommentOpts)
	return ret0
}

// PostCreateWorkoutCommentLoadUser indicates an expected call of PostCreateWorkoutCommentLoadUser.
func (mr *MockRepoMockRecorder) PostCreateWorkoutCommentLoadUser(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostCreateWorkoutCommentLoadUser", reflect.TypeOf((*MockRepo)(nil).PostCreateWorkoutCommentLoadUser), ctx)
}

// PublishEvent mocks base method.
func (m *MockRepo) PublishEvent(ctx context.Context, topic orm.EventTopic, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishEvent", ctx, topic, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishEvent indicates an expected call of PublishEvent.
func (mr *MockRepoMockRecorder) PublishEvent(ctx, topic, payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishEvent", reflect.TypeOf((*MockRepo)(nil).PublishEvent), ctx, topic, payload)
}

// RefreshTokenExists mocks base method.
func (m *MockRepo) RefreshTokenExists(ctx context.Context, refreshToken string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RefreshTokenExists", ctx, refreshToken)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RefreshTokenExists indicates an expected call of RefreshTokenExists.
func (mr *MockRepoMockRecorder) RefreshTokenExists(ctx, refreshToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokenExists", reflect.TypeOf((*MockRepo)(nil).RefreshTokenExists), ctx, refreshToken)
}

// RemoveExerciseFromRoutine mocks base method.
func (m *MockRepo) RemoveExerciseFromRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveExerciseFromRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveExerciseFromRoutine indicates an expected call of RemoveExerciseFromRoutine.
func (mr *MockRepoMockRecorder) RemoveExerciseFromRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveExerciseFromRoutine", reflect.TypeOf((*MockRepo)(nil).RemoveExerciseFromRoutine), ctx, exercise, routine)
}

// SetRoutineExercises mocks base method.
func (m *MockRepo) SetRoutineExercises(ctx context.Context, routine *orm.Routine, exercises orm.ExerciseSlice) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRoutineExercises", ctx, routine, exercises)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRoutineExercises indicates an expected call of SetRoutineExercises.
func (mr *MockRepoMockRecorder) SetRoutineExercises(ctx, routine, exercises any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRoutineExercises", reflect.TypeOf((*MockRepo)(nil).SetRoutineExercises), ctx, routine, exercises)
}

// SoftDeleteExercise mocks base method.
func (m *MockRepo) SoftDeleteExercise(ctx context.Context, p SoftDeleteExerciseParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDeleteExercise", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDeleteExercise indicates an expected call of SoftDeleteExercise.
func (mr *MockRepoMockRecorder) SoftDeleteExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteExercise", reflect.TypeOf((*MockRepo)(nil).SoftDeleteExercise), ctx, p)
}

// StoreTrace mocks base method.
func (m *MockRepo) StoreTrace(ctx context.Context, p StoreTraceParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreTrace", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreTrace indicates an expected call of StoreTrace.
func (mr *MockRepoMockRecorder) StoreTrace(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreTrace", reflect.TypeOf((*MockRepo)(nil).StoreTrace), ctx, p)
}

// Unfollow mocks base method.
func (m *MockRepo) Unfollow(ctx context.Context, p UnfollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unfollow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unfollow indicates an expected call of Unfollow.
func (mr *MockRepoMockRecorder) Unfollow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unfollow", reflect.TypeOf((*MockRepo)(nil).Unfollow), ctx, p)
}

// UpdateAuth mocks base method.
func (m *MockRepo) UpdateAuth(ctx context.Context, authID string, opts ...UpdateAuthOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, authID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAuth", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAuth indicates an expected call of UpdateAuth.
func (mr *MockRepoMockRecorder) UpdateAuth(ctx, authID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, authID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAuth", reflect.TypeOf((*MockRepo)(nil).UpdateAuth), varargs...)
}

// UpdateExercise mocks base method.
func (m *MockRepo) UpdateExercise(ctx context.Context, exerciseID string, opts ...UpdateExerciseOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exerciseID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExercise", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExercise indicates an expected call of UpdateExercise.
func (mr *MockRepoMockRecorder) UpdateExercise(ctx, exerciseID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exerciseID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExercise", reflect.TypeOf((*MockRepo)(nil).UpdateExercise), varargs...)
}

// UpdateRoutine mocks base method.
func (m *MockRepo) UpdateRoutine(ctx context.Context, routineID string, opts ...UpdateRoutineOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, routineID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateRoutine", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateRoutine indicates an expected call of UpdateRoutine.
func (mr *MockRepoMockRecorder) UpdateRoutine(ctx, routineID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, routineID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRoutine", reflect.TypeOf((*MockRepo)(nil).UpdateRoutine), varargs...)
}

// UpdateWorkout mocks base method.
func (m *MockRepo) UpdateWorkout(ctx context.Context, workoutID string, opts ...UpdateWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, workoutID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkout indicates an expected call of UpdateWorkout.
func (mr *MockRepoMockRecorder) UpdateWorkout(ctx, workoutID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, workoutID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkout", reflect.TypeOf((*MockRepo)(nil).UpdateWorkout), varargs...)
}

// UpdateWorkoutSets mocks base method.
func (m *MockRepo) UpdateWorkoutSets(ctx context.Context, workoutID string, exerciseSets []ExerciseSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkoutSets", ctx, workoutID, exerciseSets)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkoutSets indicates an expected call of UpdateWorkoutSets.
func (mr *MockRepoMockRecorder) UpdateWorkoutSets(ctx, workoutID, exerciseSets any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkoutSets", reflect.TypeOf((*MockRepo)(nil).UpdateWorkoutSets), ctx, workoutID, exerciseSets)
}

// MockTx is a mock of Tx interface.
type MockTx struct {
	ctrl     *gomock.Controller
	recorder *MockTxMockRecorder
	isgomock struct{}
}

// MockTxMockRecorder is the mock recorder for MockTx.
type MockTxMockRecorder struct {
	mock *MockTx
}

// NewMockTx creates a new mock instance.
func NewMockTx(ctrl *gomock.Controller) *MockTx {
	mock := &MockTx{ctrl: ctrl}
	mock.recorder = &MockTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTx) EXPECT() *MockTxMockRecorder {
	return m.recorder
}

// AddExerciseToRoutine mocks base method.
func (m *MockTx) AddExerciseToRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddExerciseToRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddExerciseToRoutine indicates an expected call of AddExerciseToRoutine.
func (mr *MockTxMockRecorder) AddExerciseToRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddExerciseToRoutine", reflect.TypeOf((*MockTx)(nil).AddExerciseToRoutine), ctx, exercise, routine)
}

// CompareEmailAndPassword mocks base method.
func (m *MockTx) CompareEmailAndPassword(ctx context.Context, email, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompareEmailAndPassword", ctx, email, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompareEmailAndPassword indicates an expected call of CompareEmailAndPassword.
func (mr *MockTxMockRecorder) CompareEmailAndPassword(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompareEmailAndPassword", reflect.TypeOf((*MockTx)(nil).CompareEmailAndPassword), ctx, email, password)
}

// CountNotifications mocks base method.
func (m *MockTx) CountNotifications(ctx context.Context, opts ...CountNotificationsOpt) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountNotifications", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountNotifications indicates an expected call of CountNotifications.
func (mr *MockTxMockRecorder) CountNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountNotifications", reflect.TypeOf((*MockTx)(nil).CountNotifications), varargs...)
}

// CreateAuth mocks base method.
func (m *MockTx) CreateAuth(ctx context.Context, email, password string) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAuth", ctx, email, password)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAuth indicates an expected call of CreateAuth.
func (mr *MockTxMockRecorder) CreateAuth(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAuth", reflect.TypeOf((*MockTx)(nil).CreateAuth), ctx, email, password)
}

// CreateExercise mocks base method.
func (m *MockTx) CreateExercise(ctx context.Context, p CreateExerciseParams) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateExercise", ctx, p)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateExercise indicates an expected call of CreateExercise.
func (mr *MockTxMockRecorder) CreateExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExercise", reflect.TypeOf((*MockTx)(nil).CreateExercise), ctx, p)
}

// CreateNotification mocks base method.
func (m *MockTx) CreateNotification(ctx context.Context, p CreateNotificationParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNotification", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MockTxMockRecorder) CreateNotification(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*MockTx)(nil).CreateNotification), ctx, p)
}

// CreateRoutine mocks base method.
func (m *MockTx) CreateRoutine(ctx context.Context, p CreateRoutineParams) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRoutine", ctx, p)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRoutine indicates an expected call of CreateRoutine.
func (mr *MockTxMockRecorder) CreateRoutine(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRoutine", reflect.TypeOf((*MockTx)(nil).CreateRoutine), ctx, p)
}

// CreateUser mocks base method.
func (m *MockTx) CreateUser(ctx context.Context, p CreateUserParams) (*orm.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, p)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockTxMockRecorder) CreateUser(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockTx)(nil).CreateUser), ctx, p)
}

// CreateWorkout mocks base method.
func (m *MockTx) CreateWorkout(ctx context.Context, p CreateWorkoutParams) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorkout", ctx, p)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkout indicates an expected call of CreateWorkout.
func (mr *MockTxMockRecorder) CreateWorkout(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkout", reflect.TypeOf((*MockTx)(nil).CreateWorkout), ctx, p)
}

// CreateWorkoutComment mocks base method.
func (m *MockTx) CreateWorkoutComment(ctx context.Context, p CreateWorkoutCommentParams, opts ...CreateWorkoutCommentOpts) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, p}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkoutComment indicates an expected call of CreateWorkoutComment.
func (mr *MockTxMockRecorder) CreateWorkoutComment(ctx, p any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, p}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkoutComment", reflect.TypeOf((*MockTx)(nil).CreateWorkoutComment), varargs...)
}

// DeleteRoutine mocks base method.
func (m *MockTx) DeleteRoutine(ctx context.Context, routineID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRoutine", ctx, routineID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRoutine indicates an expected call of DeleteRoutine.
func (mr *MockTxMockRecorder) DeleteRoutine(ctx, routineID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRoutine", reflect.TypeOf((*MockTx)(nil).DeleteRoutine), ctx, routineID)
}

// DeleteWorkout mocks base method.
func (m *MockTx) DeleteWorkout(ctx context.Context, opts ...DeleteWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteWorkout indicates an expected call of DeleteWorkout.
func (mr *MockTxMockRecorder) DeleteWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkout", reflect.TypeOf((*MockTx)(nil).DeleteWorkout), varargs...)
}

// Follow mocks base method.
func (m *MockTx) Follow(ctx context.Context, p FollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Follow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Follow indicates an expected call of Follow.
func (mr *MockTxMockRecorder) Follow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Follow", reflect.TypeOf((*MockTx)(nil).Follow), ctx, p)
}

// GetAuth mocks base method.
func (m *MockTx) GetAuth(ctx context.Context, opts ...GetAuthOpt) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAuth", varargs...)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuth indicates an expected call of GetAuth.
func (mr *MockTxMockRecorder) GetAuth(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuth", reflect.TypeOf((*MockTx)(nil).GetAuth), varargs...)
}

// GetExercise mocks base method.
func (m *MockTx) GetExercise(ctx context.Context, opts ...GetExerciseOpt) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExercise", varargs...)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExercise indicates an expected call of GetExercise.
func (mr *MockTxMockRecorder) GetExercise(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExercise", reflect.TypeOf((*MockTx)(nil).GetExercise), varargs...)
}

// GetPersonalBests mocks base method.
func (m *MockTx) GetPersonalBests(ctx context.Context, userIDs ...string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range userIDs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPersonalBests", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPersonalBests indicates an expected call of GetPersonalBests.
func (mr *MockTxMockRecorder) GetPersonalBests(ctx any, userIDs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, userIDs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPersonalBests", reflect.TypeOf((*MockTx)(nil).GetPersonalBests), varargs...)
}

// GetPreviousWorkoutSets mocks base method.
func (m *MockTx) GetPreviousWorkoutSets(ctx context.Context, exerciseIDs []string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPreviousWorkoutSets", ctx, exerciseIDs)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPreviousWorkoutSets indicates an expected call of GetPreviousWorkoutSets.
func (mr *MockTxMockRecorder) GetPreviousWorkoutSets(ctx, exerciseIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPreviousWorkoutSets", reflect.TypeOf((*MockTx)(nil).GetPreviousWorkoutSets), ctx, exerciseIDs)
}

// GetRoutine mocks base method.
func (m *MockTx) GetRoutine(ctx context.Context, opts ...GetRoutineOpt) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRoutine", varargs...)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRoutine indicates an expected call of GetRoutine.
func (mr *MockTxMockRecorder) GetRoutine(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRoutine", reflect.TypeOf((*MockTx)(nil).GetRoutine), varargs...)
}

// GetUser mocks base method.
func (m *MockTx) GetUser(ctx context.Context, opts ...GetUserOpt) (*orm.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *MockTxMockRecorder) GetUser(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockTx)(nil).GetUser), varargs...)
}

// GetWorkout mocks base method.
func (m *MockTx) GetWorkout(ctx context.Context, opts ...GetWorkoutOpt) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkout", varargs...)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkout indicates an expected call of GetWorkout.
func (mr *MockTxMockRecorder) GetWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkout", reflect.TypeOf((*MockTx)(nil).GetWorkout), varargs...)
}

// GetWorkoutComment mocks base method.
func (m *MockTx) GetWorkoutComment(ctx context.Context, opts ...GetWorkoutCommentOpt) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkoutComment indicates an expected call of GetWorkoutComment.
func (mr *MockTxMockRecorder) GetWorkoutComment(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkoutComment", reflect.TypeOf((*MockTx)(nil).GetWorkoutComment), varargs...)
}

// IsUserFollowedByUserID mocks base method.
func (m *MockTx) IsUserFollowedByUserID(ctx context.Context, user *orm.User, userID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUserFollowedByUserID", ctx, user, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUserFollowedByUserID indicates an expected call of IsUserFollowedByUserID.
func (mr *MockTxMockRecorder) IsUserFollowedByUserID(ctx, user, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserFollowedByUserID", reflect.TypeOf((*MockTx)(nil).IsUserFollowedByUserID), ctx, user, userID)
}

// ListExercises mocks base method.
func (m *MockTx) ListExercises(ctx context.Context, opts ...ListExercisesOpt) (orm.ExerciseSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListExercises", varargs...)
	ret0, _ := ret[0].(orm.ExerciseSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListExercises indicates an expected call of ListExercises.
func (mr *MockTxMockRecorder) ListExercises(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListExercises", reflect.TypeOf((*MockTx)(nil).ListExercises), varargs...)
}

// ListFollowees mocks base method.
func (m *MockTx) ListFollowees(ctx context.Context, userID string, opts ...ListFolloweesOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowees", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowees indicates an expected call of ListFollowees.
func (mr *MockTxMockRecorder) ListFollowees(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowees", reflect.TypeOf((*MockTx)(nil).ListFollowees), varargs...)
}

// ListFollowers mocks base method.
func (m *MockTx) ListFollowers(ctx context.Context, userID string, opts ...ListFollowersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowers indicates an expected call of ListFollowers.
func (mr *MockTxMockRecorder) ListFollowers(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowers", reflect.TypeOf((*MockTx)(nil).ListFollowers), varargs...)
}

// ListNotifications mocks base method.
func (m *MockTx) ListNotifications(ctx context.Context, opts ...ListNotificationsOpt) (orm.NotificationSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNotifications", varargs...)
	ret0, _ := ret[0].(orm.NotificationSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNotifications indicates an expected call of ListNotifications.
func (mr *MockTxMockRecorder) ListNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNotifications", reflect.TypeOf((*MockTx)(nil).ListNotifications), varargs...)
}

// ListRoutines mocks base method.
func (m *MockTx) ListRoutines(ctx context.Context, opts ...ListRoutineOpt) (orm.RoutineSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRoutines", varargs...)
	ret0, _ := ret[0].(orm.RoutineSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRoutines indicates an expected call of ListRoutines.
func (mr *MockTxMockRecorder) ListRoutines(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRoutines", reflect.TypeOf((*MockTx)(nil).ListRoutines), varargs...)
}

// ListSets mocks base method.
func (m *MockTx) ListSets(ctx context.Context, opts ...ListSetsOpt) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSets", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSets indicates an expected call of ListSets.
func (mr *MockTxMockRecorder) ListSets(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSets", reflect.TypeOf((*MockTx)(nil).ListSets), varargs...)
}

// ListUsers mocks base method.
func (m *MockTx) ListUsers(ctx context.Context, opts ...ListUsersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUsers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUsers indicates an expected call of ListUsers.
func (mr *MockTxMockRecorder) ListUsers(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockTx)(nil).ListUsers), varargs...)
}

// ListWorkouts mocks base method.
func (m *MockTx) ListWorkouts(ctx context.Context, opts ...ListWorkoutsOpt) (orm.WorkoutSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkouts", varargs...)
	ret0, _ := ret[0].(orm.WorkoutSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkouts indicates an expected call of ListWorkouts.
func (mr *MockTxMockRecorder) ListWorkouts(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkouts", reflect.TypeOf((*MockTx)(nil).ListWorkouts), varargs...)
}

// MarkNotificationsAsRead mocks base method.
func (m *MockTx) MarkNotificationsAsRead(ctx context.Context, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkNotificationsAsRead", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkNotificationsAsRead indicates an expected call of MarkNotificationsAsRead.
func (mr *MockTxMockRecorder) MarkNotificationsAsRead(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkNotificationsAsRead", reflect.TypeOf((*MockTx)(nil).MarkNotificationsAsRead), ctx, userID)
}

// PostCreateWorkoutCommentLoadUser mocks base method.
func (m *MockTx) PostCreateWorkoutCommentLoadUser(ctx context.Context) CreateWorkoutCommentOpts {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostCreateWorkoutCommentLoadUser", ctx)
	ret0, _ := ret[0].(CreateWorkoutCommentOpts)
	return ret0
}

// PostCreateWorkoutCommentLoadUser indicates an expected call of PostCreateWorkoutCommentLoadUser.
func (mr *MockTxMockRecorder) PostCreateWorkoutCommentLoadUser(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostCreateWorkoutCommentLoadUser", reflect.TypeOf((*MockTx)(nil).PostCreateWorkoutCommentLoadUser), ctx)
}

// PublishEvent mocks base method.
func (m *MockTx) PublishEvent(ctx context.Context, topic orm.EventTopic, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishEvent", ctx, topic, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishEvent indicates an expected call of PublishEvent.
func (mr *MockTxMockRecorder) PublishEvent(ctx, topic, payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishEvent", reflect.TypeOf((*MockTx)(nil).PublishEvent), ctx, topic, payload)
}

// RefreshTokenExists mocks base method.
func (m *MockTx) RefreshTokenExists(ctx context.Context, refreshToken string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RefreshTokenExists", ctx, refreshToken)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RefreshTokenExists indicates an expected call of RefreshTokenExists.
func (mr *MockTxMockRecorder) RefreshTokenExists(ctx, refreshToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokenExists", reflect.TypeOf((*MockTx)(nil).RefreshTokenExists), ctx, refreshToken)
}

// RemoveExerciseFromRoutine mocks base method.
func (m *MockTx) RemoveExerciseFromRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveExerciseFromRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveExerciseFromRoutine indicates an expected call of RemoveExerciseFromRoutine.
func (mr *MockTxMockRecorder) RemoveExerciseFromRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveExerciseFromRoutine", reflect.TypeOf((*MockTx)(nil).RemoveExerciseFromRoutine), ctx, exercise, routine)
}

// SetRoutineExercises mocks base method.
func (m *MockTx) SetRoutineExercises(ctx context.Context, routine *orm.Routine, exercises orm.ExerciseSlice) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRoutineExercises", ctx, routine, exercises)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRoutineExercises indicates an expected call of SetRoutineExercises.
func (mr *MockTxMockRecorder) SetRoutineExercises(ctx, routine, exercises any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRoutineExercises", reflect.TypeOf((*MockTx)(nil).SetRoutineExercises), ctx, routine, exercises)
}

// SoftDeleteExercise mocks base method.
func (m *MockTx) SoftDeleteExercise(ctx context.Context, p SoftDeleteExerciseParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDeleteExercise", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDeleteExercise indicates an expected call of SoftDeleteExercise.
func (mr *MockTxMockRecorder) SoftDeleteExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteExercise", reflect.TypeOf((*MockTx)(nil).SoftDeleteExercise), ctx, p)
}

// StoreTrace mocks base method.
func (m *MockTx) StoreTrace(ctx context.Context, p StoreTraceParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreTrace", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreTrace indicates an expected call of StoreTrace.
func (mr *MockTxMockRecorder) StoreTrace(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreTrace", reflect.TypeOf((*MockTx)(nil).StoreTrace), ctx, p)
}

// Unfollow mocks base method.
func (m *MockTx) Unfollow(ctx context.Context, p UnfollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unfollow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unfollow indicates an expected call of Unfollow.
func (mr *MockTxMockRecorder) Unfollow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unfollow", reflect.TypeOf((*MockTx)(nil).Unfollow), ctx, p)
}

// UpdateAuth mocks base method.
func (m *MockTx) UpdateAuth(ctx context.Context, authID string, opts ...UpdateAuthOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, authID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAuth", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAuth indicates an expected call of UpdateAuth.
func (mr *MockTxMockRecorder) UpdateAuth(ctx, authID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, authID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAuth", reflect.TypeOf((*MockTx)(nil).UpdateAuth), varargs...)
}

// UpdateExercise mocks base method.
func (m *MockTx) UpdateExercise(ctx context.Context, exerciseID string, opts ...UpdateExerciseOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exerciseID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExercise", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExercise indicates an expected call of UpdateExercise.
func (mr *MockTxMockRecorder) UpdateExercise(ctx, exerciseID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exerciseID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExercise", reflect.TypeOf((*MockTx)(nil).UpdateExercise), varargs...)
}

// UpdateRoutine mocks base method.
func (m *MockTx) UpdateRoutine(ctx context.Context, routineID string, opts ...UpdateRoutineOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, routineID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateRoutine", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateRoutine indicates an expected call of UpdateRoutine.
func (mr *MockTxMockRecorder) UpdateRoutine(ctx, routineID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, routineID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRoutine", reflect.TypeOf((*MockTx)(nil).UpdateRoutine), varargs...)
}

// UpdateWorkout mocks base method.
func (m *MockTx) UpdateWorkout(ctx context.Context, workoutID string, opts ...UpdateWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, workoutID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkout indicates an expected call of UpdateWorkout.
func (mr *MockTxMockRecorder) UpdateWorkout(ctx, workoutID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, workoutID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkout", reflect.TypeOf((*MockTx)(nil).UpdateWorkout), varargs...)
}

// UpdateWorkoutSets mocks base method.
func (m *MockTx) UpdateWorkoutSets(ctx context.Context, workoutID string, exerciseSets []ExerciseSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkoutSets", ctx, workoutID, exerciseSets)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkoutSets indicates an expected call of UpdateWorkoutSets.
func (mr *MockTxMockRecorder) UpdateWorkoutSets(ctx, workoutID, exerciseSets any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkoutSets", reflect.TypeOf((*MockTx)(nil).UpdateWorkoutSets), ctx, workoutID, exerciseSets)
}

// exec mocks base method.
func (m *MockTx) exec() *sql.Tx {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "exec")
	ret0, _ := ret[0].(*sql.Tx)
	return ret0
}

// exec indicates an expected call of exec.
func (mr *MockTxMockRecorder) exec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "exec", reflect.TypeOf((*MockTx)(nil).exec))
}

// Mockmethods is a mock of methods interface.
type Mockmethods struct {
	ctrl     *gomock.Controller
	recorder *MockmethodsMockRecorder
	isgomock struct{}
}

// MockmethodsMockRecorder is the mock recorder for Mockmethods.
type MockmethodsMockRecorder struct {
	mock *Mockmethods
}

// NewMockmethods creates a new mock instance.
func NewMockmethods(ctrl *gomock.Controller) *Mockmethods {
	mock := &Mockmethods{ctrl: ctrl}
	mock.recorder = &MockmethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockmethods) EXPECT() *MockmethodsMockRecorder {
	return m.recorder
}

// AddExerciseToRoutine mocks base method.
func (m *Mockmethods) AddExerciseToRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddExerciseToRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddExerciseToRoutine indicates an expected call of AddExerciseToRoutine.
func (mr *MockmethodsMockRecorder) AddExerciseToRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddExerciseToRoutine", reflect.TypeOf((*Mockmethods)(nil).AddExerciseToRoutine), ctx, exercise, routine)
}

// CompareEmailAndPassword mocks base method.
func (m *Mockmethods) CompareEmailAndPassword(ctx context.Context, email, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompareEmailAndPassword", ctx, email, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompareEmailAndPassword indicates an expected call of CompareEmailAndPassword.
func (mr *MockmethodsMockRecorder) CompareEmailAndPassword(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompareEmailAndPassword", reflect.TypeOf((*Mockmethods)(nil).CompareEmailAndPassword), ctx, email, password)
}

// CountNotifications mocks base method.
func (m *Mockmethods) CountNotifications(ctx context.Context, opts ...CountNotificationsOpt) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountNotifications", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountNotifications indicates an expected call of CountNotifications.
func (mr *MockmethodsMockRecorder) CountNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountNotifications", reflect.TypeOf((*Mockmethods)(nil).CountNotifications), varargs...)
}

// CreateAuth mocks base method.
func (m *Mockmethods) CreateAuth(ctx context.Context, email, password string) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAuth", ctx, email, password)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAuth indicates an expected call of CreateAuth.
func (mr *MockmethodsMockRecorder) CreateAuth(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAuth", reflect.TypeOf((*Mockmethods)(nil).CreateAuth), ctx, email, password)
}

// CreateExercise mocks base method.
func (m *Mockmethods) CreateExercise(ctx context.Context, p CreateExerciseParams) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateExercise", ctx, p)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateExercise indicates an expected call of CreateExercise.
func (mr *MockmethodsMockRecorder) CreateExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExercise", reflect.TypeOf((*Mockmethods)(nil).CreateExercise), ctx, p)
}

// CreateNotification mocks base method.
func (m *Mockmethods) CreateNotification(ctx context.Context, p CreateNotificationParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNotification", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MockmethodsMockRecorder) CreateNotification(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*Mockmethods)(nil).CreateNotification), ctx, p)
}

// CreateRoutine mocks base method.
func (m *Mockmethods) CreateRoutine(ctx context.Context, p CreateRoutineParams) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRoutine", ctx, p)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRoutine indicates an expected call of CreateRoutine.
func (mr *MockmethodsMockRecorder) CreateRoutine(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRoutine", reflect.TypeOf((*Mockmethods)(nil).CreateRoutine), ctx, p)
}

// CreateUser mocks base method.
func (m *Mockmethods) CreateUser(ctx context.Context, p CreateUserParams) (*orm.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, p)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockmethodsMockRecorder) CreateUser(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*Mockmethods)(nil).CreateUser), ctx, p)
}

// CreateWorkout mocks base method.
func (m *Mockmethods) CreateWorkout(ctx context.Context, p CreateWorkoutParams) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorkout", ctx, p)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkout indicates an expected call of CreateWorkout.
func (mr *MockmethodsMockRecorder) CreateWorkout(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkout", reflect.TypeOf((*Mockmethods)(nil).CreateWorkout), ctx, p)
}

// CreateWorkoutComment mocks base method.
func (m *Mockmethods) CreateWorkoutComment(ctx context.Context, p CreateWorkoutCommentParams, opts ...CreateWorkoutCommentOpts) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, p}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkoutComment indicates an expected call of CreateWorkoutComment.
func (mr *MockmethodsMockRecorder) CreateWorkoutComment(ctx, p any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, p}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkoutComment", reflect.TypeOf((*Mockmethods)(nil).CreateWorkoutComment), varargs...)
}

// DeleteRoutine mocks base method.
func (m *Mockmethods) DeleteRoutine(ctx context.Context, routineID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRoutine", ctx, routineID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRoutine indicates an expected call of DeleteRoutine.
func (mr *MockmethodsMockRecorder) DeleteRoutine(ctx, routineID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRoutine", reflect.TypeOf((*Mockmethods)(nil).DeleteRoutine), ctx, routineID)
}

// DeleteWorkout mocks base method.
func (m *Mockmethods) DeleteWorkout(ctx context.Context, opts ...DeleteWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteWorkout indicates an expected call of DeleteWorkout.
func (mr *MockmethodsMockRecorder) DeleteWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkout", reflect.TypeOf((*Mockmethods)(nil).DeleteWorkout), varargs...)
}

// Follow mocks base method.
func (m *Mockmethods) Follow(ctx context.Context, p FollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Follow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Follow indicates an expected call of Follow.
func (mr *MockmethodsMockRecorder) Follow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Follow", reflect.TypeOf((*Mockmethods)(nil).Follow), ctx, p)
}

// GetAuth mocks base method.
func (m *Mockmethods) GetAuth(ctx context.Context, opts ...GetAuthOpt) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAuth", varargs...)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuth indicates an expected call of GetAuth.
func (mr *MockmethodsMockRecorder) GetAuth(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuth", reflect.TypeOf((*Mockmethods)(nil).GetAuth), varargs...)
}

// GetExercise mocks base method.
func (m *Mockmethods) GetExercise(ctx context.Context, opts ...GetExerciseOpt) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExercise", varargs...)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExercise indicates an expected call of GetExercise.
func (mr *MockmethodsMockRecorder) GetExercise(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExercise", reflect.TypeOf((*Mockmethods)(nil).GetExercise), varargs...)
}

// GetPersonalBests mocks base method.
func (m *Mockmethods) GetPersonalBests(ctx context.Context, userIDs ...string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range userIDs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPersonalBests", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPersonalBests indicates an expected call of GetPersonalBests.
func (mr *MockmethodsMockRecorder) GetPersonalBests(ctx any, userIDs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, userIDs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPersonalBests", reflect.TypeOf((*Mockmethods)(nil).GetPersonalBests), varargs...)
}

// GetPreviousWorkoutSets mocks base method.
func (m *Mockmethods) GetPreviousWorkoutSets(ctx context.Context, exerciseIDs []string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPreviousWorkoutSets", ctx, exerciseIDs)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPreviousWorkoutSets indicates an expected call of GetPreviousWorkoutSets.
func (mr *MockmethodsMockRecorder) GetPreviousWorkoutSets(ctx, exerciseIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPreviousWorkoutSets", reflect.TypeOf((*Mockmethods)(nil).GetPreviousWorkoutSets), ctx, exerciseIDs)
}

// GetRoutine mocks base method.
func (m *Mockmethods) GetRoutine(ctx context.Context, opts ...GetRoutineOpt) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRoutine", varargs...)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRoutine indicates an expected call of GetRoutine.
func (mr *MockmethodsMockRecorder) GetRoutine(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRoutine", reflect.TypeOf((*Mockmethods)(nil).GetRoutine), varargs...)
}

// GetUser mocks base method.
func (m *Mockmethods) GetUser(ctx context.Context, opts ...GetUserOpt) (*orm.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *MockmethodsMockRecorder) GetUser(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*Mockmethods)(nil).GetUser), varargs...)
}

// GetWorkout mocks base method.
func (m *Mockmethods) GetWorkout(ctx context.Context, opts ...GetWorkoutOpt) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkout", varargs...)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkout indicates an expected call of GetWorkout.
func (mr *MockmethodsMockRecorder) GetWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkout", reflect.TypeOf((*Mockmethods)(nil).GetWorkout), varargs...)
}

// GetWorkoutComment mocks base method.
func (m *Mockmethods) GetWorkoutComment(ctx context.Context, opts ...GetWorkoutCommentOpt) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkoutComment indicates an expected call of GetWorkoutComment.
func (mr *MockmethodsMockRecorder) GetWorkoutComment(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkoutComment", reflect.TypeOf((*Mockmethods)(nil).GetWorkoutComment), varargs...)
}

// IsUserFollowedByUserID mocks base method.
func (m *Mockmethods) IsUserFollowedByUserID(ctx context.Context, user *orm.User, userID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUserFollowedByUserID", ctx, user, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUserFollowedByUserID indicates an expected call of IsUserFollowedByUserID.
func (mr *MockmethodsMockRecorder) IsUserFollowedByUserID(ctx, user, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserFollowedByUserID", reflect.TypeOf((*Mockmethods)(nil).IsUserFollowedByUserID), ctx, user, userID)
}

// ListExercises mocks base method.
func (m *Mockmethods) ListExercises(ctx context.Context, opts ...ListExercisesOpt) (orm.ExerciseSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListExercises", varargs...)
	ret0, _ := ret[0].(orm.ExerciseSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListExercises indicates an expected call of ListExercises.
func (mr *MockmethodsMockRecorder) ListExercises(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListExercises", reflect.TypeOf((*Mockmethods)(nil).ListExercises), varargs...)
}

// ListFollowees mocks base method.
func (m *Mockmethods) ListFollowees(ctx context.Context, userID string, opts ...ListFolloweesOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowees", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowees indicates an expected call of ListFollowees.
func (mr *MockmethodsMockRecorder) ListFollowees(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowees", reflect.TypeOf((*Mockmethods)(nil).ListFollowees), varargs...)
}

// ListFollowers mocks base method.
func (m *Mockmethods) ListFollowers(ctx context.Context, userID string, opts ...ListFollowersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowers indicates an expected call of ListFollowers.
func (mr *MockmethodsMockRecorder) ListFollowers(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowers", reflect.TypeOf((*Mockmethods)(nil).ListFollowers), varargs...)
}

// ListNotifications mocks base method.
func (m *Mockmethods) ListNotifications(ctx context.Context, opts ...ListNotificationsOpt) (orm.NotificationSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNotifications", varargs...)
	ret0, _ := ret[0].(orm.NotificationSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNotifications indicates an expected call of ListNotifications.
func (mr *MockmethodsMockRecorder) ListNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNotifications", reflect.TypeOf((*Mockmethods)(nil).ListNotifications), varargs...)
}

// ListRoutines mocks base method.
func (m *Mockmethods) ListRoutines(ctx context.Context, opts ...ListRoutineOpt) (orm.RoutineSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRoutines", varargs...)
	ret0, _ := ret[0].(orm.RoutineSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRoutines indicates an expected call of ListRoutines.
func (mr *MockmethodsMockRecorder) ListRoutines(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRoutines", reflect.TypeOf((*Mockmethods)(nil).ListRoutines), varargs...)
}

// ListSets mocks base method.
func (m *Mockmethods) ListSets(ctx context.Context, opts ...ListSetsOpt) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSets", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSets indicates an expected call of ListSets.
func (mr *MockmethodsMockRecorder) ListSets(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSets", reflect.TypeOf((*Mockmethods)(nil).ListSets), varargs...)
}

// ListUsers mocks base method.
func (m *Mockmethods) ListUsers(ctx context.Context, opts ...ListUsersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUsers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUsers indicates an expected call of ListUsers.
func (mr *MockmethodsMockRecorder) ListUsers(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*Mockmethods)(nil).ListUsers), varargs...)
}

// ListWorkouts mocks base method.
func (m *Mockmethods) ListWorkouts(ctx context.Context, opts ...ListWorkoutsOpt) (orm.WorkoutSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkouts", varargs...)
	ret0, _ := ret[0].(orm.WorkoutSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkouts indicates an expected call of ListWorkouts.
func (mr *MockmethodsMockRecorder) ListWorkouts(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkouts", reflect.TypeOf((*Mockmethods)(nil).ListWorkouts), varargs...)
}

// MarkNotificationsAsRead mocks base method.
func (m *Mockmethods) MarkNotificationsAsRead(ctx context.Context, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkNotificationsAsRead", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkNotificationsAsRead indicates an expected call of MarkNotificationsAsRead.
func (mr *MockmethodsMockRecorder) MarkNotificationsAsRead(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkNotificationsAsRead", reflect.TypeOf((*Mockmethods)(nil).MarkNotificationsAsRead), ctx, userID)
}

// PostCreateWorkoutCommentLoadUser mocks base method.
func (m *Mockmethods) PostCreateWorkoutCommentLoadUser(ctx context.Context) CreateWorkoutCommentOpts {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostCreateWorkoutCommentLoadUser", ctx)
	ret0, _ := ret[0].(CreateWorkoutCommentOpts)
	return ret0
}

// PostCreateWorkoutCommentLoadUser indicates an expected call of PostCreateWorkoutCommentLoadUser.
func (mr *MockmethodsMockRecorder) PostCreateWorkoutCommentLoadUser(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostCreateWorkoutCommentLoadUser", reflect.TypeOf((*Mockmethods)(nil).PostCreateWorkoutCommentLoadUser), ctx)
}

// PublishEvent mocks base method.
func (m *Mockmethods) PublishEvent(ctx context.Context, topic orm.EventTopic, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishEvent", ctx, topic, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishEvent indicates an expected call of PublishEvent.
func (mr *MockmethodsMockRecorder) PublishEvent(ctx, topic, payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishEvent", reflect.TypeOf((*Mockmethods)(nil).PublishEvent), ctx, topic, payload)
}

// RefreshTokenExists mocks base method.
func (m *Mockmethods) RefreshTokenExists(ctx context.Context, refreshToken string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RefreshTokenExists", ctx, refreshToken)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RefreshTokenExists indicates an expected call of RefreshTokenExists.
func (mr *MockmethodsMockRecorder) RefreshTokenExists(ctx, refreshToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokenExists", reflect.TypeOf((*Mockmethods)(nil).RefreshTokenExists), ctx, refreshToken)
}

// RemoveExerciseFromRoutine mocks base method.
func (m *Mockmethods) RemoveExerciseFromRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveExerciseFromRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveExerciseFromRoutine indicates an expected call of RemoveExerciseFromRoutine.
func (mr *MockmethodsMockRecorder) RemoveExerciseFromRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveExerciseFromRoutine", reflect.TypeOf((*Mockmethods)(nil).RemoveExerciseFromRoutine), ctx, exercise, routine)
}

// SetRoutineExercises mocks base method.
func (m *Mockmethods) SetRoutineExercises(ctx context.Context, routine *orm.Routine, exercises orm.ExerciseSlice) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRoutineExercises", ctx, routine, exercises)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRoutineExercises indicates an expected call of SetRoutineExercises.
func (mr *MockmethodsMockRecorder) SetRoutineExercises(ctx, routine, exercises any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRoutineExercises", reflect.TypeOf((*Mockmethods)(nil).SetRoutineExercises), ctx, routine, exercises)
}

// SoftDeleteExercise mocks base method.
func (m *Mockmethods) SoftDeleteExercise(ctx context.Context, p SoftDeleteExerciseParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDeleteExercise", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDeleteExercise indicates an expected call of SoftDeleteExercise.
func (mr *MockmethodsMockRecorder) SoftDeleteExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteExercise", reflect.TypeOf((*Mockmethods)(nil).SoftDeleteExercise), ctx, p)
}

// StoreTrace mocks base method.
func (m *Mockmethods) StoreTrace(ctx context.Context, p StoreTraceParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreTrace", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreTrace indicates an expected call of StoreTrace.
func (mr *MockmethodsMockRecorder) StoreTrace(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreTrace", reflect.TypeOf((*Mockmethods)(nil).StoreTrace), ctx, p)
}

// Unfollow mocks base method.
func (m *Mockmethods) Unfollow(ctx context.Context, p UnfollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unfollow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unfollow indicates an expected call of Unfollow.
func (mr *MockmethodsMockRecorder) Unfollow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unfollow", reflect.TypeOf((*Mockmethods)(nil).Unfollow), ctx, p)
}

// UpdateAuth mocks base method.
func (m *Mockmethods) UpdateAuth(ctx context.Context, authID string, opts ...UpdateAuthOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, authID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAuth", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAuth indicates an expected call of UpdateAuth.
func (mr *MockmethodsMockRecorder) UpdateAuth(ctx, authID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, authID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAuth", reflect.TypeOf((*Mockmethods)(nil).UpdateAuth), varargs...)
}

// UpdateExercise mocks base method.
func (m *Mockmethods) UpdateExercise(ctx context.Context, exerciseID string, opts ...UpdateExerciseOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exerciseID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExercise", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExercise indicates an expected call of UpdateExercise.
func (mr *MockmethodsMockRecorder) UpdateExercise(ctx, exerciseID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exerciseID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExercise", reflect.TypeOf((*Mockmethods)(nil).UpdateExercise), varargs...)
}

// UpdateRoutine mocks base method.
func (m *Mockmethods) UpdateRoutine(ctx context.Context, routineID string, opts ...UpdateRoutineOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, routineID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateRoutine", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateRoutine indicates an expected call of UpdateRoutine.
func (mr *MockmethodsMockRecorder) UpdateRoutine(ctx, routineID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, routineID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRoutine", reflect.TypeOf((*Mockmethods)(nil).UpdateRoutine), varargs...)
}

// UpdateWorkout mocks base method.
func (m *Mockmethods) UpdateWorkout(ctx context.Context, workoutID string, opts ...UpdateWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, workoutID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkout indicates an expected call of UpdateWorkout.
func (mr *MockmethodsMockRecorder) UpdateWorkout(ctx, workoutID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, workoutID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkout", reflect.TypeOf((*Mockmethods)(nil).UpdateWorkout), varargs...)
}

// UpdateWorkoutSets mocks base method.
func (m *Mockmethods) UpdateWorkoutSets(ctx context.Context, workoutID string, exerciseSets []ExerciseSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkoutSets", ctx, workoutID, exerciseSets)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkoutSets indicates an expected call of UpdateWorkoutSets.
func (mr *MockmethodsMockRecorder) UpdateWorkoutSets(ctx, workoutID, exerciseSets any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkoutSets", reflect.TypeOf((*Mockmethods)(nil).UpdateWorkoutSets), ctx, workoutID, exerciseSets)
}

// MocksetMethods is a mock of setMethods interface.
type MocksetMethods struct {
	ctrl     *gomock.Controller
	recorder *MocksetMethodsMockRecorder
	isgomock struct{}
}

// MocksetMethodsMockRecorder is the mock recorder for MocksetMethods.
type MocksetMethodsMockRecorder struct {
	mock *MocksetMethods
}

// NewMocksetMethods creates a new mock instance.
func NewMocksetMethods(ctrl *gomock.Controller) *MocksetMethods {
	mock := &MocksetMethods{ctrl: ctrl}
	mock.recorder = &MocksetMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocksetMethods) EXPECT() *MocksetMethodsMockRecorder {
	return m.recorder
}

// GetPersonalBests mocks base method.
func (m *MocksetMethods) GetPersonalBests(ctx context.Context, userIDs ...string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range userIDs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPersonalBests", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPersonalBests indicates an expected call of GetPersonalBests.
func (mr *MocksetMethodsMockRecorder) GetPersonalBests(ctx any, userIDs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, userIDs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPersonalBests", reflect.TypeOf((*MocksetMethods)(nil).GetPersonalBests), varargs...)
}

// GetPreviousWorkoutSets mocks base method.
func (m *MocksetMethods) GetPreviousWorkoutSets(ctx context.Context, exerciseIDs []string) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPreviousWorkoutSets", ctx, exerciseIDs)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPreviousWorkoutSets indicates an expected call of GetPreviousWorkoutSets.
func (mr *MocksetMethodsMockRecorder) GetPreviousWorkoutSets(ctx, exerciseIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPreviousWorkoutSets", reflect.TypeOf((*MocksetMethods)(nil).GetPreviousWorkoutSets), ctx, exerciseIDs)
}

// ListSets mocks base method.
func (m *MocksetMethods) ListSets(ctx context.Context, opts ...ListSetsOpt) (orm.SetSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListSets", varargs...)
	ret0, _ := ret[0].(orm.SetSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSets indicates an expected call of ListSets.
func (mr *MocksetMethodsMockRecorder) ListSets(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSets", reflect.TypeOf((*MocksetMethods)(nil).ListSets), varargs...)
}

// MockauthMethods is a mock of authMethods interface.
type MockauthMethods struct {
	ctrl     *gomock.Controller
	recorder *MockauthMethodsMockRecorder
	isgomock struct{}
}

// MockauthMethodsMockRecorder is the mock recorder for MockauthMethods.
type MockauthMethodsMockRecorder struct {
	mock *MockauthMethods
}

// NewMockauthMethods creates a new mock instance.
func NewMockauthMethods(ctrl *gomock.Controller) *MockauthMethods {
	mock := &MockauthMethods{ctrl: ctrl}
	mock.recorder = &MockauthMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockauthMethods) EXPECT() *MockauthMethodsMockRecorder {
	return m.recorder
}

// CompareEmailAndPassword mocks base method.
func (m *MockauthMethods) CompareEmailAndPassword(ctx context.Context, email, password string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CompareEmailAndPassword", ctx, email, password)
	ret0, _ := ret[0].(error)
	return ret0
}

// CompareEmailAndPassword indicates an expected call of CompareEmailAndPassword.
func (mr *MockauthMethodsMockRecorder) CompareEmailAndPassword(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CompareEmailAndPassword", reflect.TypeOf((*MockauthMethods)(nil).CompareEmailAndPassword), ctx, email, password)
}

// CreateAuth mocks base method.
func (m *MockauthMethods) CreateAuth(ctx context.Context, email, password string) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateAuth", ctx, email, password)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAuth indicates an expected call of CreateAuth.
func (mr *MockauthMethodsMockRecorder) CreateAuth(ctx, email, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAuth", reflect.TypeOf((*MockauthMethods)(nil).CreateAuth), ctx, email, password)
}

// GetAuth mocks base method.
func (m *MockauthMethods) GetAuth(ctx context.Context, opts ...GetAuthOpt) (*orm.Auth, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAuth", varargs...)
	ret0, _ := ret[0].(*orm.Auth)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAuth indicates an expected call of GetAuth.
func (mr *MockauthMethodsMockRecorder) GetAuth(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAuth", reflect.TypeOf((*MockauthMethods)(nil).GetAuth), varargs...)
}

// RefreshTokenExists mocks base method.
func (m *MockauthMethods) RefreshTokenExists(ctx context.Context, refreshToken string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RefreshTokenExists", ctx, refreshToken)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RefreshTokenExists indicates an expected call of RefreshTokenExists.
func (mr *MockauthMethodsMockRecorder) RefreshTokenExists(ctx, refreshToken any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RefreshTokenExists", reflect.TypeOf((*MockauthMethods)(nil).RefreshTokenExists), ctx, refreshToken)
}

// UpdateAuth mocks base method.
func (m *MockauthMethods) UpdateAuth(ctx context.Context, authID string, opts ...UpdateAuthOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, authID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateAuth", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAuth indicates an expected call of UpdateAuth.
func (mr *MockauthMethodsMockRecorder) UpdateAuth(ctx, authID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, authID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAuth", reflect.TypeOf((*MockauthMethods)(nil).UpdateAuth), varargs...)
}

// MockuserMethods is a mock of userMethods interface.
type MockuserMethods struct {
	ctrl     *gomock.Controller
	recorder *MockuserMethodsMockRecorder
	isgomock struct{}
}

// MockuserMethodsMockRecorder is the mock recorder for MockuserMethods.
type MockuserMethodsMockRecorder struct {
	mock *MockuserMethods
}

// NewMockuserMethods creates a new mock instance.
func NewMockuserMethods(ctrl *gomock.Controller) *MockuserMethods {
	mock := &MockuserMethods{ctrl: ctrl}
	mock.recorder = &MockuserMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockuserMethods) EXPECT() *MockuserMethodsMockRecorder {
	return m.recorder
}

// CreateUser mocks base method.
func (m *MockuserMethods) CreateUser(ctx context.Context, p CreateUserParams) (*orm.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", ctx, p)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser.
func (mr *MockuserMethodsMockRecorder) CreateUser(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockuserMethods)(nil).CreateUser), ctx, p)
}

// Follow mocks base method.
func (m *MockuserMethods) Follow(ctx context.Context, p FollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Follow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Follow indicates an expected call of Follow.
func (mr *MockuserMethodsMockRecorder) Follow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Follow", reflect.TypeOf((*MockuserMethods)(nil).Follow), ctx, p)
}

// GetUser mocks base method.
func (m *MockuserMethods) GetUser(ctx context.Context, opts ...GetUserOpt) (*orm.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*orm.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser.
func (mr *MockuserMethodsMockRecorder) GetUser(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockuserMethods)(nil).GetUser), varargs...)
}

// IsUserFollowedByUserID mocks base method.
func (m *MockuserMethods) IsUserFollowedByUserID(ctx context.Context, user *orm.User, userID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUserFollowedByUserID", ctx, user, userID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUserFollowedByUserID indicates an expected call of IsUserFollowedByUserID.
func (mr *MockuserMethodsMockRecorder) IsUserFollowedByUserID(ctx, user, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserFollowedByUserID", reflect.TypeOf((*MockuserMethods)(nil).IsUserFollowedByUserID), ctx, user, userID)
}

// ListFollowees mocks base method.
func (m *MockuserMethods) ListFollowees(ctx context.Context, userID string, opts ...ListFolloweesOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowees", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowees indicates an expected call of ListFollowees.
func (mr *MockuserMethodsMockRecorder) ListFollowees(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowees", reflect.TypeOf((*MockuserMethods)(nil).ListFollowees), varargs...)
}

// ListFollowers mocks base method.
func (m *MockuserMethods) ListFollowers(ctx context.Context, userID string, opts ...ListFollowersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, userID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListFollowers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListFollowers indicates an expected call of ListFollowers.
func (mr *MockuserMethodsMockRecorder) ListFollowers(ctx, userID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, userID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListFollowers", reflect.TypeOf((*MockuserMethods)(nil).ListFollowers), varargs...)
}

// ListUsers mocks base method.
func (m *MockuserMethods) ListUsers(ctx context.Context, opts ...ListUsersOpt) (orm.UserSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListUsers", varargs...)
	ret0, _ := ret[0].(orm.UserSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListUsers indicates an expected call of ListUsers.
func (mr *MockuserMethodsMockRecorder) ListUsers(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUsers", reflect.TypeOf((*MockuserMethods)(nil).ListUsers), varargs...)
}

// Unfollow mocks base method.
func (m *MockuserMethods) Unfollow(ctx context.Context, p UnfollowParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unfollow", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unfollow indicates an expected call of Unfollow.
func (mr *MockuserMethodsMockRecorder) Unfollow(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unfollow", reflect.TypeOf((*MockuserMethods)(nil).Unfollow), ctx, p)
}

// MocktraceMethods is a mock of traceMethods interface.
type MocktraceMethods struct {
	ctrl     *gomock.Controller
	recorder *MocktraceMethodsMockRecorder
	isgomock struct{}
}

// MocktraceMethodsMockRecorder is the mock recorder for MocktraceMethods.
type MocktraceMethodsMockRecorder struct {
	mock *MocktraceMethods
}

// NewMocktraceMethods creates a new mock instance.
func NewMocktraceMethods(ctrl *gomock.Controller) *MocktraceMethods {
	mock := &MocktraceMethods{ctrl: ctrl}
	mock.recorder = &MocktraceMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktraceMethods) EXPECT() *MocktraceMethodsMockRecorder {
	return m.recorder
}

// StoreTrace mocks base method.
func (m *MocktraceMethods) StoreTrace(ctx context.Context, p StoreTraceParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreTrace", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreTrace indicates an expected call of StoreTrace.
func (mr *MocktraceMethodsMockRecorder) StoreTrace(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreTrace", reflect.TypeOf((*MocktraceMethods)(nil).StoreTrace), ctx, p)
}

// MockroutineMethods is a mock of routineMethods interface.
type MockroutineMethods struct {
	ctrl     *gomock.Controller
	recorder *MockroutineMethodsMockRecorder
	isgomock struct{}
}

// MockroutineMethodsMockRecorder is the mock recorder for MockroutineMethods.
type MockroutineMethodsMockRecorder struct {
	mock *MockroutineMethods
}

// NewMockroutineMethods creates a new mock instance.
func NewMockroutineMethods(ctrl *gomock.Controller) *MockroutineMethods {
	mock := &MockroutineMethods{ctrl: ctrl}
	mock.recorder = &MockroutineMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockroutineMethods) EXPECT() *MockroutineMethodsMockRecorder {
	return m.recorder
}

// AddExerciseToRoutine mocks base method.
func (m *MockroutineMethods) AddExerciseToRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddExerciseToRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddExerciseToRoutine indicates an expected call of AddExerciseToRoutine.
func (mr *MockroutineMethodsMockRecorder) AddExerciseToRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddExerciseToRoutine", reflect.TypeOf((*MockroutineMethods)(nil).AddExerciseToRoutine), ctx, exercise, routine)
}

// CreateRoutine mocks base method.
func (m *MockroutineMethods) CreateRoutine(ctx context.Context, p CreateRoutineParams) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateRoutine", ctx, p)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateRoutine indicates an expected call of CreateRoutine.
func (mr *MockroutineMethodsMockRecorder) CreateRoutine(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateRoutine", reflect.TypeOf((*MockroutineMethods)(nil).CreateRoutine), ctx, p)
}

// DeleteRoutine mocks base method.
func (m *MockroutineMethods) DeleteRoutine(ctx context.Context, routineID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRoutine", ctx, routineID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRoutine indicates an expected call of DeleteRoutine.
func (mr *MockroutineMethodsMockRecorder) DeleteRoutine(ctx, routineID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRoutine", reflect.TypeOf((*MockroutineMethods)(nil).DeleteRoutine), ctx, routineID)
}

// GetRoutine mocks base method.
func (m *MockroutineMethods) GetRoutine(ctx context.Context, opts ...GetRoutineOpt) (*orm.Routine, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRoutine", varargs...)
	ret0, _ := ret[0].(*orm.Routine)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRoutine indicates an expected call of GetRoutine.
func (mr *MockroutineMethodsMockRecorder) GetRoutine(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRoutine", reflect.TypeOf((*MockroutineMethods)(nil).GetRoutine), varargs...)
}

// ListRoutines mocks base method.
func (m *MockroutineMethods) ListRoutines(ctx context.Context, opts ...ListRoutineOpt) (orm.RoutineSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListRoutines", varargs...)
	ret0, _ := ret[0].(orm.RoutineSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListRoutines indicates an expected call of ListRoutines.
func (mr *MockroutineMethodsMockRecorder) ListRoutines(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListRoutines", reflect.TypeOf((*MockroutineMethods)(nil).ListRoutines), varargs...)
}

// RemoveExerciseFromRoutine mocks base method.
func (m *MockroutineMethods) RemoveExerciseFromRoutine(ctx context.Context, exercise *orm.Exercise, routine *orm.Routine) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveExerciseFromRoutine", ctx, exercise, routine)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveExerciseFromRoutine indicates an expected call of RemoveExerciseFromRoutine.
func (mr *MockroutineMethodsMockRecorder) RemoveExerciseFromRoutine(ctx, exercise, routine any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveExerciseFromRoutine", reflect.TypeOf((*MockroutineMethods)(nil).RemoveExerciseFromRoutine), ctx, exercise, routine)
}

// SetRoutineExercises mocks base method.
func (m *MockroutineMethods) SetRoutineExercises(ctx context.Context, routine *orm.Routine, exercises orm.ExerciseSlice) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetRoutineExercises", ctx, routine, exercises)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetRoutineExercises indicates an expected call of SetRoutineExercises.
func (mr *MockroutineMethodsMockRecorder) SetRoutineExercises(ctx, routine, exercises any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRoutineExercises", reflect.TypeOf((*MockroutineMethods)(nil).SetRoutineExercises), ctx, routine, exercises)
}

// UpdateRoutine mocks base method.
func (m *MockroutineMethods) UpdateRoutine(ctx context.Context, routineID string, opts ...UpdateRoutineOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, routineID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateRoutine", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateRoutine indicates an expected call of UpdateRoutine.
func (mr *MockroutineMethodsMockRecorder) UpdateRoutine(ctx, routineID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, routineID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateRoutine", reflect.TypeOf((*MockroutineMethods)(nil).UpdateRoutine), varargs...)
}

// MockworkoutMethods is a mock of workoutMethods interface.
type MockworkoutMethods struct {
	ctrl     *gomock.Controller
	recorder *MockworkoutMethodsMockRecorder
	isgomock struct{}
}

// MockworkoutMethodsMockRecorder is the mock recorder for MockworkoutMethods.
type MockworkoutMethodsMockRecorder struct {
	mock *MockworkoutMethods
}

// NewMockworkoutMethods creates a new mock instance.
func NewMockworkoutMethods(ctrl *gomock.Controller) *MockworkoutMethods {
	mock := &MockworkoutMethods{ctrl: ctrl}
	mock.recorder = &MockworkoutMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockworkoutMethods) EXPECT() *MockworkoutMethodsMockRecorder {
	return m.recorder
}

// CreateWorkout mocks base method.
func (m *MockworkoutMethods) CreateWorkout(ctx context.Context, p CreateWorkoutParams) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWorkout", ctx, p)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkout indicates an expected call of CreateWorkout.
func (mr *MockworkoutMethodsMockRecorder) CreateWorkout(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkout", reflect.TypeOf((*MockworkoutMethods)(nil).CreateWorkout), ctx, p)
}

// CreateWorkoutComment mocks base method.
func (m *MockworkoutMethods) CreateWorkoutComment(ctx context.Context, p CreateWorkoutCommentParams, opts ...CreateWorkoutCommentOpts) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, p}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWorkoutComment indicates an expected call of CreateWorkoutComment.
func (mr *MockworkoutMethodsMockRecorder) CreateWorkoutComment(ctx, p any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, p}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWorkoutComment", reflect.TypeOf((*MockworkoutMethods)(nil).CreateWorkoutComment), varargs...)
}

// DeleteWorkout mocks base method.
func (m *MockworkoutMethods) DeleteWorkout(ctx context.Context, opts ...DeleteWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteWorkout indicates an expected call of DeleteWorkout.
func (mr *MockworkoutMethodsMockRecorder) DeleteWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWorkout", reflect.TypeOf((*MockworkoutMethods)(nil).DeleteWorkout), varargs...)
}

// GetWorkout mocks base method.
func (m *MockworkoutMethods) GetWorkout(ctx context.Context, opts ...GetWorkoutOpt) (*orm.Workout, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkout", varargs...)
	ret0, _ := ret[0].(*orm.Workout)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkout indicates an expected call of GetWorkout.
func (mr *MockworkoutMethodsMockRecorder) GetWorkout(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkout", reflect.TypeOf((*MockworkoutMethods)(nil).GetWorkout), varargs...)
}

// GetWorkoutComment mocks base method.
func (m *MockworkoutMethods) GetWorkoutComment(ctx context.Context, opts ...GetWorkoutCommentOpt) (*orm.WorkoutComment, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetWorkoutComment", varargs...)
	ret0, _ := ret[0].(*orm.WorkoutComment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWorkoutComment indicates an expected call of GetWorkoutComment.
func (mr *MockworkoutMethodsMockRecorder) GetWorkoutComment(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWorkoutComment", reflect.TypeOf((*MockworkoutMethods)(nil).GetWorkoutComment), varargs...)
}

// ListWorkouts mocks base method.
func (m *MockworkoutMethods) ListWorkouts(ctx context.Context, opts ...ListWorkoutsOpt) (orm.WorkoutSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListWorkouts", varargs...)
	ret0, _ := ret[0].(orm.WorkoutSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListWorkouts indicates an expected call of ListWorkouts.
func (mr *MockworkoutMethodsMockRecorder) ListWorkouts(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListWorkouts", reflect.TypeOf((*MockworkoutMethods)(nil).ListWorkouts), varargs...)
}

// PostCreateWorkoutCommentLoadUser mocks base method.
func (m *MockworkoutMethods) PostCreateWorkoutCommentLoadUser(ctx context.Context) CreateWorkoutCommentOpts {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PostCreateWorkoutCommentLoadUser", ctx)
	ret0, _ := ret[0].(CreateWorkoutCommentOpts)
	return ret0
}

// PostCreateWorkoutCommentLoadUser indicates an expected call of PostCreateWorkoutCommentLoadUser.
func (mr *MockworkoutMethodsMockRecorder) PostCreateWorkoutCommentLoadUser(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostCreateWorkoutCommentLoadUser", reflect.TypeOf((*MockworkoutMethods)(nil).PostCreateWorkoutCommentLoadUser), ctx)
}

// UpdateWorkout mocks base method.
func (m *MockworkoutMethods) UpdateWorkout(ctx context.Context, workoutID string, opts ...UpdateWorkoutOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, workoutID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWorkout", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkout indicates an expected call of UpdateWorkout.
func (mr *MockworkoutMethodsMockRecorder) UpdateWorkout(ctx, workoutID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, workoutID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkout", reflect.TypeOf((*MockworkoutMethods)(nil).UpdateWorkout), varargs...)
}

// UpdateWorkoutSets mocks base method.
func (m *MockworkoutMethods) UpdateWorkoutSets(ctx context.Context, workoutID string, exerciseSets []ExerciseSet) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateWorkoutSets", ctx, workoutID, exerciseSets)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateWorkoutSets indicates an expected call of UpdateWorkoutSets.
func (mr *MockworkoutMethodsMockRecorder) UpdateWorkoutSets(ctx, workoutID, exerciseSets any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWorkoutSets", reflect.TypeOf((*MockworkoutMethods)(nil).UpdateWorkoutSets), ctx, workoutID, exerciseSets)
}

// MockexerciseMethods is a mock of exerciseMethods interface.
type MockexerciseMethods struct {
	ctrl     *gomock.Controller
	recorder *MockexerciseMethodsMockRecorder
	isgomock struct{}
}

// MockexerciseMethodsMockRecorder is the mock recorder for MockexerciseMethods.
type MockexerciseMethodsMockRecorder struct {
	mock *MockexerciseMethods
}

// NewMockexerciseMethods creates a new mock instance.
func NewMockexerciseMethods(ctrl *gomock.Controller) *MockexerciseMethods {
	mock := &MockexerciseMethods{ctrl: ctrl}
	mock.recorder = &MockexerciseMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockexerciseMethods) EXPECT() *MockexerciseMethodsMockRecorder {
	return m.recorder
}

// CreateExercise mocks base method.
func (m *MockexerciseMethods) CreateExercise(ctx context.Context, p CreateExerciseParams) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateExercise", ctx, p)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateExercise indicates an expected call of CreateExercise.
func (mr *MockexerciseMethodsMockRecorder) CreateExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateExercise", reflect.TypeOf((*MockexerciseMethods)(nil).CreateExercise), ctx, p)
}

// GetExercise mocks base method.
func (m *MockexerciseMethods) GetExercise(ctx context.Context, opts ...GetExerciseOpt) (*orm.Exercise, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetExercise", varargs...)
	ret0, _ := ret[0].(*orm.Exercise)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExercise indicates an expected call of GetExercise.
func (mr *MockexerciseMethodsMockRecorder) GetExercise(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExercise", reflect.TypeOf((*MockexerciseMethods)(nil).GetExercise), varargs...)
}

// ListExercises mocks base method.
func (m *MockexerciseMethods) ListExercises(ctx context.Context, opts ...ListExercisesOpt) (orm.ExerciseSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListExercises", varargs...)
	ret0, _ := ret[0].(orm.ExerciseSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListExercises indicates an expected call of ListExercises.
func (mr *MockexerciseMethodsMockRecorder) ListExercises(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListExercises", reflect.TypeOf((*MockexerciseMethods)(nil).ListExercises), varargs...)
}

// SoftDeleteExercise mocks base method.
func (m *MockexerciseMethods) SoftDeleteExercise(ctx context.Context, p SoftDeleteExerciseParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SoftDeleteExercise", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// SoftDeleteExercise indicates an expected call of SoftDeleteExercise.
func (mr *MockexerciseMethodsMockRecorder) SoftDeleteExercise(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SoftDeleteExercise", reflect.TypeOf((*MockexerciseMethods)(nil).SoftDeleteExercise), ctx, p)
}

// UpdateExercise mocks base method.
func (m *MockexerciseMethods) UpdateExercise(ctx context.Context, exerciseID string, opts ...UpdateExerciseOpt) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, exerciseID}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateExercise", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateExercise indicates an expected call of UpdateExercise.
func (mr *MockexerciseMethodsMockRecorder) UpdateExercise(ctx, exerciseID any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, exerciseID}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateExercise", reflect.TypeOf((*MockexerciseMethods)(nil).UpdateExercise), varargs...)
}

// MocknotificationMethods is a mock of notificationMethods interface.
type MocknotificationMethods struct {
	ctrl     *gomock.Controller
	recorder *MocknotificationMethodsMockRecorder
	isgomock struct{}
}

// MocknotificationMethodsMockRecorder is the mock recorder for MocknotificationMethods.
type MocknotificationMethodsMockRecorder struct {
	mock *MocknotificationMethods
}

// NewMocknotificationMethods creates a new mock instance.
func NewMocknotificationMethods(ctrl *gomock.Controller) *MocknotificationMethods {
	mock := &MocknotificationMethods{ctrl: ctrl}
	mock.recorder = &MocknotificationMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocknotificationMethods) EXPECT() *MocknotificationMethodsMockRecorder {
	return m.recorder
}

// CountNotifications mocks base method.
func (m *MocknotificationMethods) CountNotifications(ctx context.Context, opts ...CountNotificationsOpt) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CountNotifications", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountNotifications indicates an expected call of CountNotifications.
func (mr *MocknotificationMethodsMockRecorder) CountNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountNotifications", reflect.TypeOf((*MocknotificationMethods)(nil).CountNotifications), varargs...)
}

// CreateNotification mocks base method.
func (m *MocknotificationMethods) CreateNotification(ctx context.Context, p CreateNotificationParams) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateNotification", ctx, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateNotification indicates an expected call of CreateNotification.
func (mr *MocknotificationMethodsMockRecorder) CreateNotification(ctx, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateNotification", reflect.TypeOf((*MocknotificationMethods)(nil).CreateNotification), ctx, p)
}

// ListNotifications mocks base method.
func (m *MocknotificationMethods) ListNotifications(ctx context.Context, opts ...ListNotificationsOpt) (orm.NotificationSlice, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListNotifications", varargs...)
	ret0, _ := ret[0].(orm.NotificationSlice)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListNotifications indicates an expected call of ListNotifications.
func (mr *MocknotificationMethodsMockRecorder) ListNotifications(ctx any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListNotifications", reflect.TypeOf((*MocknotificationMethods)(nil).ListNotifications), varargs...)
}

// MarkNotificationsAsRead mocks base method.
func (m *MocknotificationMethods) MarkNotificationsAsRead(ctx context.Context, userID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkNotificationsAsRead", ctx, userID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkNotificationsAsRead indicates an expected call of MarkNotificationsAsRead.
func (mr *MocknotificationMethodsMockRecorder) MarkNotificationsAsRead(ctx, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkNotificationsAsRead", reflect.TypeOf((*MocknotificationMethods)(nil).MarkNotificationsAsRead), ctx, userID)
}

// MockpubSubMethods is a mock of pubSubMethods interface.
type MockpubSubMethods struct {
	ctrl     *gomock.Controller
	recorder *MockpubSubMethodsMockRecorder
	isgomock struct{}
}

// MockpubSubMethodsMockRecorder is the mock recorder for MockpubSubMethods.
type MockpubSubMethodsMockRecorder struct {
	mock *MockpubSubMethods
}

// NewMockpubSubMethods creates a new mock instance.
func NewMockpubSubMethods(ctrl *gomock.Controller) *MockpubSubMethods {
	mock := &MockpubSubMethods{ctrl: ctrl}
	mock.recorder = &MockpubSubMethodsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockpubSubMethods) EXPECT() *MockpubSubMethodsMockRecorder {
	return m.recorder
}

// PublishEvent mocks base method.
func (m *MockpubSubMethods) PublishEvent(ctx context.Context, topic orm.EventTopic, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishEvent", ctx, topic, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// PublishEvent indicates an expected call of PublishEvent.
func (mr *MockpubSubMethodsMockRecorder) PublishEvent(ctx, topic, payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishEvent", reflect.TypeOf((*MockpubSubMethods)(nil).PublishEvent), ctx, topic, payload)
}
