// Code generated by SQLBoiler 4.17.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package orm

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// PersonalBest is an object representing the database table.
type PersonalBest struct {
	ID         null.String  `boil:"id" json:"id,omitempty" toml:"id" yaml:"id,omitempty"`
	WorkoutID  null.String  `boil:"workout_id" json:"workout_id,omitempty" toml:"workout_id" yaml:"workout_id,omitempty"`
	ExerciseID null.String  `boil:"exercise_id" json:"exercise_id,omitempty" toml:"exercise_id" yaml:"exercise_id,omitempty"`
	UserID     null.String  `boil:"user_id" json:"user_id,omitempty" toml:"user_id" yaml:"user_id,omitempty"`
	Weight     null.Float64 `boil:"weight" json:"weight,omitempty" toml:"weight" yaml:"weight,omitempty"`
	Reps       null.Int     `boil:"reps" json:"reps,omitempty" toml:"reps" yaml:"reps,omitempty"`
	CreatedAt  null.Time    `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
}

var PersonalBestColumns = struct {
	ID         string
	WorkoutID  string
	ExerciseID string
	UserID     string
	Weight     string
	Reps       string
	CreatedAt  string
}{
	ID:         "id",
	WorkoutID:  "workout_id",
	ExerciseID: "exercise_id",
	UserID:     "user_id",
	Weight:     "weight",
	Reps:       "reps",
	CreatedAt:  "created_at",
}

var PersonalBestTableColumns = struct {
	ID         string
	WorkoutID  string
	ExerciseID string
	UserID     string
	Weight     string
	Reps       string
	CreatedAt  string
}{
	ID:         "personal_bests.id",
	WorkoutID:  "personal_bests.workout_id",
	ExerciseID: "personal_bests.exercise_id",
	UserID:     "personal_bests.user_id",
	Weight:     "personal_bests.weight",
	Reps:       "personal_bests.reps",
	CreatedAt:  "personal_bests.created_at",
}

// Generated where

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var PersonalBestWhere = struct {
	ID         whereHelpernull_String
	WorkoutID  whereHelpernull_String
	ExerciseID whereHelpernull_String
	UserID     whereHelpernull_String
	Weight     whereHelpernull_Float64
	Reps       whereHelpernull_Int
	CreatedAt  whereHelpernull_Time
}{
	ID:         whereHelpernull_String{field: "\"getstronger\".\"personal_bests\".\"id\""},
	WorkoutID:  whereHelpernull_String{field: "\"getstronger\".\"personal_bests\".\"workout_id\""},
	ExerciseID: whereHelpernull_String{field: "\"getstronger\".\"personal_bests\".\"exercise_id\""},
	UserID:     whereHelpernull_String{field: "\"getstronger\".\"personal_bests\".\"user_id\""},
	Weight:     whereHelpernull_Float64{field: "\"getstronger\".\"personal_bests\".\"weight\""},
	Reps:       whereHelpernull_Int{field: "\"getstronger\".\"personal_bests\".\"reps\""},
	CreatedAt:  whereHelpernull_Time{field: "\"getstronger\".\"personal_bests\".\"created_at\""},
}

var (
	personalBestAllColumns            = []string{"id", "workout_id", "exercise_id", "user_id", "weight", "reps", "created_at"}
	personalBestColumnsWithoutDefault = []string{}
	personalBestColumnsWithDefault    = []string{"id", "workout_id", "exercise_id", "user_id", "weight", "reps", "created_at"}
	personalBestPrimaryKeyColumns     = []string{}
	personalBestGeneratedColumns      = []string{}
)

type (
	// PersonalBestSlice is an alias for a slice of pointers to PersonalBest.
	// This should almost always be used instead of []PersonalBest.
	PersonalBestSlice []*PersonalBest
	// PersonalBestHook is the signature for custom PersonalBest hook methods
	PersonalBestHook func(context.Context, boil.ContextExecutor, *PersonalBest) error

	personalBestQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	personalBestType           = reflect.TypeOf(&PersonalBest{})
	personalBestMapping        = queries.MakeStructMapping(personalBestType)
	personalBestInsertCacheMut sync.RWMutex
	personalBestInsertCache    = make(map[string]insertCache)
	personalBestUpdateCacheMut sync.RWMutex
	personalBestUpdateCache    = make(map[string]updateCache)
	personalBestUpsertCacheMut sync.RWMutex
	personalBestUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var personalBestAfterSelectMu sync.Mutex
var personalBestAfterSelectHooks []PersonalBestHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *PersonalBest) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range personalBestAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPersonalBestHook registers your hook function for all future operations.
func AddPersonalBestHook(hookPoint boil.HookPoint, personalBestHook PersonalBestHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		personalBestAfterSelectMu.Lock()
		personalBestAfterSelectHooks = append(personalBestAfterSelectHooks, personalBestHook)
		personalBestAfterSelectMu.Unlock()
	}
}

// One returns a single personalBest record from the query.
func (q personalBestQuery) One(ctx context.Context, exec boil.ContextExecutor) (*PersonalBest, error) {
	o := &PersonalBest{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "orm: failed to execute a one query for personal_bests")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all PersonalBest records from the query.
func (q personalBestQuery) All(ctx context.Context, exec boil.ContextExecutor) (PersonalBestSlice, error) {
	var o []*PersonalBest

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "orm: failed to assign all query results to PersonalBest slice")
	}

	if len(personalBestAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all PersonalBest records in the query.
func (q personalBestQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "orm: failed to count personal_bests rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q personalBestQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "orm: failed to check if personal_bests exists")
	}

	return count > 0, nil
}

// PersonalBests retrieves all the records using an executor.
func PersonalBests(mods ...qm.QueryMod) personalBestQuery {
	mods = append(mods, qm.From("\"getstronger\".\"personal_bests\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"getstronger\".\"personal_bests\".*"})
	}

	return personalBestQuery{q}
}
